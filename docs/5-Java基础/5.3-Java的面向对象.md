# Java的面向对象

## 从面向对象说起
### 面向过程与面向对象
以描述“人吃饭”这一现象为例：
- 面向过程：

    吃(人,饭)

- 面向对象：

    人.吃(饭)
    
面向过程以“动作”为核心（方法），动作的执行者与被执行者均为方法的参数；

面向过程以“执行者”为核心（对象），动作为方法，被执行者为参数。更加符合人类的思考逻辑。

## 面向对象的基本概念
### 对象、类
- 万物皆对象(Object)
- 类(class)为对象的抽象（抽出相似部分），对象为类的实例

### 继承、实现
一个类可“继承”(extends)其它类的属性、方法，这个类就称为子类，被继承的类叫父类。Java为单继承，一个类只能有一个父类

一个类可“实现”(implements)其它接口，接口也是一系列规范，定义了一系列方法，类implements接口后需要去实现接口定义的方法。

### 抽象类
抽象类为abstract修饰的类，是类的抽象，也是规范。
抽象类为所有子类提供了一个通用模版，子类可以在这个模版基础上进行扩展，避免了子类设计的随意性。

- 有抽象方法(abstract修饰，且没有实现体的方法)的类只能定义为抽象类，但抽象类中也可以有普通方法，同时抽象类也可以不含抽象方法
- 抽象类不可实例化（即不能用new关键字来创建对象），只用于子类继承
- 一般子类继承抽象类后需要实现抽象类中的抽象方法；抽象子类继承父抽象类后可不实现其抽象方法，而交由下级子类去实现。

### 内部类
#### 内部类的特点
JDK从1.1开始就有内部类的概念，内部类即是将一个类定义在另一个类中。
内部类有以下特点：

1. 权限修饰符

    普通类（非内部类）的权限修饰符只能为public, default，因此普通类在同包内是肯定可以访问到的，而内部类还可使用private, protected。
2. 内部类访问外部类

    内部类可直接访问外部类的属性，这里的“直接访问”指的是不需要创建对象，直接引用就可以（private修饰的属性也可直接访问）。如：
    ```java
    public class Outer {
        private String name = "Akira";
    
        class Inner {
            void visitOuter() {
                System.out.println("Hello " + name); // Hello Akira （这里直接访问外部类Outer中的name属性）
            }
        }
    
        public static void main(String[] args) {
            Outer outer = new Outer();
            Inner inner = outer.new Inner();
            inner.visitOuter();
        }
    }
    ```
    若Inner类也有name属性，则在Inner类中引用name或this.name，使用的是Inner类中的name。
    通过Outer.this.name访问外部类中的name属性。如：
    ```java
    public class Outer {
        private String name = "Akira";
    
        class Inner {
            private String name = "Allen";
            void visitOuter() {
                System.out.println("Hello " + name); // Hello Allen（外部类中的name属性）
                System.out.println("Hello " + Outer.this.name); // Hello Akira（外部类Outer中的name属性）
            }
        }
    
        public static void main(String[] args) {
            Outer outer = new Outer();
            Inner inner = outer.new Inner();
            inner.visitOuter();
        }
    }
    
    ```
    （若Outer需要访问Inner中的某个属性，仍然需要先创建个Inner对象）。
3. 创建内部类需要先有外部类

    如上面的创建方式：
    ```java
    Outer outer = new Outer();
    Inner inner = outer.new Inner();
    ```
    需要先创建外部类再创建内部类。
4. 内部类中不能有静态成员（静态属性、静态方法），静态常量除外(final修饰)。

因此内部类适合于：控制访问或暴露接口、隐藏实现

#### 内部类的定义位置
内部类的定义位置很灵活。
- 定义于方法同级

    如：
    ```java
    public class Outer {
        public void hello() {}
    
        class Inner {}
    }
    ```
- 定义于方法内

    定义于方法内的内部类只能在方法内访问。同样还可定义在方法的某个代码块中，这样也只能在此代码块中访问，如if代码块中。

    如：
    ```java
    public class Outer {
        public void hello() {
            class Inner {}
        }
    }
    ```
    或：
    ```java
    public class Outer {
        public void hello(boolean bo) {
            if (bo) {
                class Inner {}    
            }
        }
    }
    ```
    或：
    ```java
    public class Outer {
        public AbstractInner hello() {
            return new AbstractInner() {
                @Override
                void hello() {
                    System.out.println("hello");
                }
            };
        }
    }
    
    abstract class AbstractInner {
        abstract void hello();
    }
    ```
    这里Outer类的hello方法需要返回一个AbstractInner，在hello方法中同时定义及实例化，实例化后作为hello方法的参数。这被称为匿名内部类（并未显式设置类的名称）。
- 参数中定义

    如：
    ```java
    public class DoSomething {
        public void hello(AbstractInner abstractInner) {
            abstractInner.hello();
        }
    
        public static void main(String[] args) {
            DoSomething doSomething = new DoSomething();
            doSomething.hello(new AbstractInner() {
                @Override
                void hello() {
                    System.out.println("Hello");
                }
            });
        }
    }
    
    abstract class AbstractInner {
        abstract void hello();
    }
    ```
    在main方法里调用doSomething.hello方法时同时定义一个内部类并实例化，实例化后作为hello方法的参数。这也被称为匿名内部类。

### 静态内部类
有static修饰的内部类。

- 静态内部类中可以有静态成员
- 不能从静态内部类中直接访问外部类属性、方法
- 创建内部类也勿须先创建外部类

    ```java
    public class Outer {
        private String name = "Akira";
    
        static class Inner {
            public static String name = "Allen";
    
            public static void hello() {
                System.out.println("Hello " + name);
            }
        }
    
        public static void main(String[] args) {
            Outer.Inner inner = new Outer.Inner();
            Outer.Inner.hello();
        }
    }
    ```


### 接口
接口(interface)为抽象类的抽象，是规范，同时也是标志。

- 接口中的属性总为public修饰的静态常量，即自动包含：public static final。
- 接口中的方法总为public修饰的抽象方法，即自动包含：public abstract。

### 重载overload
同一个方法（名）的不同实现（参数不同）。

重载要求：
- 同一个类，同一个方法名
- 参数列表不同（个数，类型，顺序）

重载与修饰符，参数名，返回值无关。构造方法也可以重载。

### 重写override
子类不使用父类中定义好的方法，而进行重写（不影响父类及该父类下其它子类）。

重写要求：
1. 方法名称，参数列表和返回类型相同
2. 修饰符更开放

    权限修饰符比父类方法的权限修饰符更开放（public > protected > default > private）,但被覆盖的父类方法不应是private修饰
3. 返回值更局限

    返回值类型应为父类返回值类型或其子类,例如：
    ```java
    class A{}
    class B extends A{}
 
    class Person{
        protected A test(){
            return new A();
        }
    }
    class Teacher extends Person{
        public B test(){
            return new B();
        }
    }
    ```
4. 受检异常更局限

    - 子类中的方法若抛出受检异常，则所抛出的受检异常只能是父类中对应方法所抛出的受检异常或其子类异常；
    - 若父类方法不抛出受检异常，则子类对应方法则不允许抛出受检异常；




