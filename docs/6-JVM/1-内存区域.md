# 内存区域
1. 程序计数器
    1. 每个线程都有一个独立的程序计数器
    2. 用以表示当前线程所执行的字节码行号指示器，线程切换后能恢复到正确的执行位置
2. Java虚拟机栈
    1. 由栈帧组成。每个方法在执行的过程对应着：创建栈帧、栈帧在虚拟机中入栈、栈帧在虚拟栈中出栈。栈帧包括：
        1. 局部变量表
            > 存放8种基本数据类型 + 引用数据类型
        2. 操作数栈
        3. 动态链接
        4. 方法出入口
    2. 栈的大小一般可以动态扩展（根据虚拟机）
        1. 线程请求的栈深度大于虚拟机所允许的深度： StackOverflowError
        2. 栈扩展时无法申请到足够的内存： OutOfMemoryError
3. 本地方法栈
    > 与Java虚拟机栈类似，只不过是用于执行Native方法（Java虚拟机栈用于执行Java方法）
4. Java堆
    1. 虚拟机中最大的一块，线程共享，几乎所有的对象实例都在此分配
        > 一些优化技术会改变这个规则，如：栈上分配、标题替换
    2. 同栈一样，大部分虚拟机实现的堆都是可以动态扩展的（-Xmx, -Xms）
        > 堆中没有足够的内存分配实例且无法再扩展时： OutOfMemoryError
    3. 堆可进一步划分为以下区域
        1. TLAB
            > 线程私有的分配缓冲区（Thread Local Allocation Buffer）。由于堆线程共享，为了避免分配对象时内存地址产生竞争，可以为每个线程分配一个单独使用的缓冲区
        2. 新生代
            > 由于现在的GC都是采用分代收集算法，不同的“代”有不同的收集方式。新生代中对象存活时间一般较短，因此GC较频繁。新生代又可划分为：
            1. Eden区
            2. From Survivor区
            3. To Survivor区
        3. 老年代
            > 保存存活得比较久的对象，一般GC没新生代频繁（存活得比较久，因此下次GC后大概率还是会存活）。
        4. 永久代
            > 在1.7的HotSpot虚拟机中用以实现方法区（在1.8废除）
5. 方法区
    1. 各个线程共享
    2. 存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码
    3. HotSpot 1.7中使用永久代来实现，1.8 使用元空间来实现
        1. -XX:MaxPermSize 永久代最大值，大部分情况下默认64Mb
        2. -XX:MaxMetaspaceSize 元空间最大值，默认无上限，即系统最大内存
        3. -XX:MetaspaceSize 元空间初始大小，默认动态调整
    4. 常量存储于（运行时）常量池中。常量主要由编译期生成，但也具备动态性，比如可使用String::intern方法将字符串存放到常量池中。
        > HotSpot 1.7中已将常量池从永久代中移除
6. 直接内存
    1. 并不是虚拟机运行时数据区的一部分，但内存不足时，也会产生OutOfMemoryError。
    2. 比如NIO可以通过Native函数库使用直接内存，并通过一个在Java堆中的DirectByteBuffer对象作为直接内存的引用进行操作
    3. 避免了在Java堆和Native堆中来回复制数据，在一些场景中能显著提高性能。