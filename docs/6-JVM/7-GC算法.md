# GC算法 
## 标记-清除算法
先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
>1. 其实过程要更加复杂，万一中间“已死”的对象又“活”了呢？
>2. 清除后会有内存碎片，这时可以选择是否对内存进行压缩，如 CMS GC。

## 复制算法
1. 内存分为三块：Eden区、From Survivor区、To Survivor区（其默认大小比例为：8:1:1）。
2. 每次只使用Eden和From Survivor（对象优先在Eden区分配）
3. GC后存活对象移至To Survivor（同时这个To Survivor变成From Survivor）
4. 由于新生代在GC后大概只会留下2%的对象，因此To Survivor一般是能存下的，当To Survivor存不下时存至老年代（分配担保）

## 标记-整理算法
老年代一般不使用复制算法，因此大部分对象在GC后都会存活，**老年代可采用标记-整理算法**。
先标记出所有需要回收的对象，在标记完成后统一将活着的对象朝一端移动，最后再清理边界以外的内存区域。