# synchronized与Lock
## synchronized与Lock比较
1. 类型及使用不同
    > Lock是一个接口，而synchronized是Java中的关键字。synchronized是隐式使用，可对代码块、方法使用；Lock为显式使用，只对代码块使用
2. 对异常的处理
    > synchronized在其代码块发生异常时，会自动释放锁；Lock则不然，因此一般在finally释放Lock锁
3. Lock提供更多的特性
    1. lockInterruptibly
    2. tryLock
    3. ReentrantLock提供fair lock
    0. 读写锁（ReadWriteLock其实是另一个顶级接口）
4. 实现原理
    1. synchronized使用JVM来实现
    2. Lock代码层面实现（CAS操作）
5. JDK更钟爱synchronized
    ```
    JDK1.5中，synchronized是性能低效的。因为这是一个重量级操作，它对性能最大的影响是阻塞的是实现，挂起线程和恢复线程的操作都需要
    转入内核态中完成，这些操作给系统的并发性带来了很大的压力。相比之下使用Java提供的Lock对象，性能更高一些。多线程环境下，
    synchronized的吞吐量下降的非常严重，而ReentrankLock则能基本保持在同一个比较稳定的水平上。
    
    到了JDK1.6，发生了变化，对synchronize加入了很多优化措施，有自适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。
    导致在JDK1.6上synchronize的性能并不比Lock差。官方也表示，他们也更支持synchronize，在未来的版本中还有优化余地，
    所以还是提倡在synchronized能实现需求的情况下，优先考虑使用synchronized来进行同步。
    ```
## synchronized的优化
### 锁升级
Synchronized的升级顺序是 无锁-->偏向锁-->轻量级锁-->重量级锁，顺内不可逆。
> Java SE 1.6中为了减少获得锁和释放锁带来的 性能消耗而引入的偏向锁和轻量级锁
#### 偏向锁
当一个线程访问同步代码块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，偏向锁是一个可重入的锁，
以后该线程在进入和退出该同步代码块时不需要花费 CAS 操作来加锁和解锁，而只需简单的测试一下对象头的 Mark Word 里是否存储着指向当前线程的偏向锁(当前线程的线程ID)，
如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下 Mark Word 中偏向锁的标识是否设置成 1（表示当前是偏向锁），如果偏向锁标识是1，
则使用 CAS 进行锁获取，偏向锁标识不是1，则尝试使用 CAS 将对象头的偏向锁指向当前线程，上述两种CAS获取锁的操作，如果CAS操作成功则获取到了偏向锁，
失败则代表出现了锁竞争，需要锁撤销操作。
#### 锁撤销
偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。
偏向锁的撤销需要等待拥有偏向锁的线程到达全局安全点（在这个时间点上没有字节码正在执行），会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，
如果线程不处于活动状态，则将锁的对象的对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行**(判断是否需要持有锁)，
遍历偏向对象的锁记录，查看使用情况，如果还需要持有偏向锁，则偏向锁升级为轻量级锁**，如果不需要持有偏向锁了，则将锁对象恢复成无锁状态，最后唤醒暂停的线程。
#### 轻量级锁
线程在执行同步块之前，JVM 会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的 Mark Word 复制到锁记录中，
官方称为 Displaced Mark Word。然后线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，
如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁，自旋有一定次数，如果超过设置自旋的次数则升级到重量级锁，
或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。
#### 轻量级锁解锁
轻量级解锁时，会使用原子的 CAS 操作来将 Displaced Mark Word 替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。
**例如：**T1线程持有锁，T2线程自旋，但是T2线程自旋最大次数已经过了，则自旋失败，进行锁升级到重量级锁，T2线程阻塞，这时T1执行完了同步代码块，
进行轻量级锁解锁，但是这时Mark Word中的标志位已经从原来的00(偏向锁)变成了10(中练级锁)，解锁会CAS失败，T1会进行解锁(释放监视器，释放锁)，并唤醒线程T2.
#### 重量级锁
Synchronized是非公平锁,Synchronized在线程进入阻塞队列时，等待的线程会先尝试获取锁，如果获取不到就进入阻塞队列，这明显对于已经进入队列的线程是不公平的。

### 锁粗化
将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁，避免频繁的加锁解锁操作。比如StringBuffer的append方法。
### 锁消除
Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，经过逃逸分析，
去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间

## 公平锁与非公平锁
### 公平锁
多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。
1. 优点：所有的线程都能得到资源，不会饿死在队列中。
2. 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。
### 非公平锁
多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。
1. 优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。
2. 缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。
